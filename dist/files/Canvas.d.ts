/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */
import { MultiTouchSpace } from './Space';
import { VisualForm, Font } from "./Form";
import { Pt, Bound } from "./Pt";
import { Img } from './Image';
import { PtLike, GroupLike, PtsCanvasRenderingContext2D, DefaultFormStyle, PtLikeIterable, PtIterable } from "./Types";
export declare class CanvasSpace extends MultiTouchSpace {
    protected _canvas: HTMLCanvasElement;
    protected _container: Element;
    protected _pixelScale: number;
    protected _autoResize: boolean;
    protected _bgcolor: string;
    protected _ctx: PtsCanvasRenderingContext2D;
    protected _offscreen: boolean;
    protected _offCanvas: HTMLCanvasElement;
    protected _offCtx: PtsCanvasRenderingContext2D;
    protected _initialResize: boolean;
    constructor(elem: string | Element, callback?: Function);
    protected _createElement(elem: string, id: any): HTMLElement;
    private _ready;
    setup(opt: {
        bgcolor?: string;
        resize?: boolean;
        retina?: boolean;
        offscreen?: boolean;
    }): this;
    set autoResize(auto: boolean);
    get autoResize(): boolean;
    resize(b: Bound, evt?: Event): this;
    protected _resizeHandler(evt: Event): void;
    set background(bg: string);
    get background(): string;
    get pixelScale(): number;
    get hasOffscreen(): boolean;
    get offscreenCtx(): PtsCanvasRenderingContext2D;
    get offscreenCanvas(): HTMLCanvasElement;
    getForm(): CanvasForm;
    get element(): HTMLCanvasElement;
    get parent(): Element;
    get ready(): boolean;
    get ctx(): PtsCanvasRenderingContext2D;
    clear(bg?: string): this;
    clearOffscreen(bg?: string): this;
    protected playItems(time: number): void;
    dispose(): this;
}
export declare class CanvasForm extends VisualForm {
    protected _space: CanvasSpace;
    protected _ctx: CanvasRenderingContext2D;
    protected _estimateTextWidth: (string: any) => number;
    protected _style: DefaultFormStyle;
    constructor(space: CanvasSpace);
    get space(): CanvasSpace;
    get ctx(): PtsCanvasRenderingContext2D;
    useOffscreen(off?: boolean, clear?: boolean | string): this;
    renderOffscreen(offset?: PtLike): void;
    alpha(a: number): this;
    fill(c: string | boolean | CanvasGradient | CanvasPattern): this;
    stroke(c: string | boolean | CanvasGradient | CanvasPattern, width?: number, linejoin?: CanvasLineJoin, linecap?: CanvasLineCap): this;
    gradient(stops: [number, string][] | string[]): ((area1: GroupLike, area2?: GroupLike) => CanvasGradient);
    composite(mode?: string): this;
    clip(): this;
    dash(segments?: PtLike | boolean, offset?: number): this;
    font(sizeOrFont: number | Font, weight?: string, style?: string, lineHeight?: number, family?: string): this;
    fontWidthEstimate(estimate?: boolean): this;
    getTextWidth(c: string): number;
    protected _textTruncate(str: string, width: number, tail?: string): [string, number];
    protected _textAlign(box: PtLikeIterable, vertical: string, offset?: PtLike, center?: Pt): Pt;
    reset(): this;
    protected _paint(): void;
    static paint(ctx: CanvasRenderingContext2D, fn: (ctx: any) => {}, fill?: string, stroke?: string, strokeWidth?: number): void;
    static point(ctx: CanvasRenderingContext2D, p: PtLike, radius?: number, shape?: string): void;
    point(p: PtLike, radius?: number, shape?: string): this;
    static circle(ctx: CanvasRenderingContext2D, pt: PtLike, radius?: number): void;
    circle(pts: PtLikeIterable): this;
    static ellipse(ctx: CanvasRenderingContext2D, pt: PtLike, radius: PtLike, rotation?: number, startAngle?: number, endAngle?: number, cc?: boolean): void;
    ellipse(pt: PtLike, radius: PtLike, rotation?: number, startAngle?: number, endAngle?: number, cc?: boolean): this;
    static arc(ctx: CanvasRenderingContext2D, pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): void;
    arc(pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): this;
    static square(ctx: CanvasRenderingContext2D, pt: PtLike, halfsize: number): void;
    square(pt: PtLike, halfsize: number): this;
    static line(ctx: CanvasRenderingContext2D, pts: PtLikeIterable): void;
    line(pts: PtLikeIterable): this;
    static polygon(ctx: CanvasRenderingContext2D, pts: PtLikeIterable): void;
    polygon(pts: PtLikeIterable): this;
    static rect(ctx: CanvasRenderingContext2D, pts: PtLikeIterable): void;
    rect(pts: PtLikeIterable): this;
    static image(ctx: CanvasRenderingContext2D, ptOrRect: PtLike | PtLikeIterable, img: CanvasImageSource | Img, orig?: PtLikeIterable): void;
    image(ptOrRect: PtLike | PtLikeIterable, img: CanvasImageSource | Img, orig?: PtLikeIterable): this;
    static imageData(ctx: CanvasRenderingContext2D, ptOrRect: PtLike | PtLikeIterable, img: ImageData): void;
    imageData(ptOrRect: PtLike | PtLikeIterable, img: ImageData): this;
    static text(ctx: CanvasRenderingContext2D, pt: PtLike, txt: string, maxWidth?: number): void;
    text(pt: PtLike, txt: string, maxWidth?: number): this;
    textBox(box: PtIterable, txt: string, verticalAlign?: string, tail?: string, overrideBaseline?: boolean): this;
    paragraphBox(box: PtLikeIterable, txt: string, lineHeight?: number, verticalAlign?: string, crop?: boolean): this;
    alignText(alignment?: CanvasTextAlign, baseline?: CanvasTextBaseline): this;
    log(txt: any): this;
}
